# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateTodo {
  _avg: TodoAvgAggregate
  _count: TodoCountAggregate
  _max: TodoMaxAggregate
  _min: TodoMinAggregate
  _sum: TodoSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyTodo(data: [TodoCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneTodo(data: TodoCreateInput!): Todo!
  createOneUser(data: UserCreateInput!): User!
  deleteManyTodo(where: TodoWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneTodo(where: TodoWhereUniqueInput!): Todo
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyTodo(data: TodoUpdateManyMutationInput!, where: TodoWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneTodo(data: TodoUpdateInput!, where: TodoWhereUniqueInput!): Todo
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneTodo(create: TodoCreateInput!, update: TodoUpdateInput!, where: TodoWhereUniqueInput!): Todo!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  aggregateTodo(cursor: TodoWhereUniqueInput, orderBy: [TodoOrderByWithRelationInput!], skip: Int, take: Int, where: TodoWhereInput): AggregateTodo!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstTodo(cursor: TodoWhereUniqueInput, distinct: [TodoScalarFieldEnum!], orderBy: [TodoOrderByWithRelationInput!], skip: Int, take: Int, where: TodoWhereInput): Todo
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByTodo(by: [TodoScalarFieldEnum!]!, having: TodoScalarWhereWithAggregatesInput, orderBy: [TodoOrderByWithAggregationInput!], skip: Int, take: Int, where: TodoWhereInput): [TodoGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  todo(where: TodoWhereUniqueInput!): Todo
  todos(cursor: TodoWhereUniqueInput, distinct: [TodoScalarFieldEnum!], orderBy: [TodoOrderByWithRelationInput!], skip: Int, take: Int, where: TodoWhereInput): [Todo!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Todo {
  assgin: User
  assignById: Int
  author: User!
  authorId: Int!
  body: String!
  createdAt: DateTime!
  expiredAt: DateTime!
  id: Int!
  title: String!
  updatedAt: DateTime!
}

type TodoAvgAggregate {
  assignById: Float
  authorId: Float
  id: Float
}

input TodoAvgOrderByAggregateInput {
  assignById: SortOrder
  authorId: SortOrder
  id: SortOrder
}

type TodoCountAggregate {
  _all: Int!
  assignById: Int!
  authorId: Int!
  body: Int!
  createdAt: Int!
  expiredAt: Int!
  id: Int!
  title: Int!
  updatedAt: Int!
}

input TodoCountOrderByAggregateInput {
  assignById: SortOrder
  authorId: SortOrder
  body: SortOrder
  createdAt: SortOrder
  expiredAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input TodoCreateInput {
  assgin: UserCreateNestedOneWithoutAssginTodosInput
  author: UserCreateNestedOneWithoutCreatedTodosInput!
  body: String!
  createdAt: DateTime
  expiredAt: DateTime!
  title: String!
  updatedAt: DateTime
}

input TodoCreateManyAssginInput {
  authorId: Int!
  body: String!
  createdAt: DateTime
  expiredAt: DateTime!
  id: Int
  title: String!
  updatedAt: DateTime
}

input TodoCreateManyAssginInputEnvelope {
  data: [TodoCreateManyAssginInput!]!
  skipDuplicates: Boolean
}

input TodoCreateManyAuthorInput {
  assignById: Int
  body: String!
  createdAt: DateTime
  expiredAt: DateTime!
  id: Int
  title: String!
  updatedAt: DateTime
}

input TodoCreateManyAuthorInputEnvelope {
  data: [TodoCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input TodoCreateManyInput {
  assignById: Int
  authorId: Int!
  body: String!
  createdAt: DateTime
  expiredAt: DateTime!
  id: Int
  title: String!
  updatedAt: DateTime
}

input TodoCreateNestedManyWithoutAssginInput {
  connect: [TodoWhereUniqueInput!]
  connectOrCreate: [TodoCreateOrConnectWithoutAssginInput!]
  create: [TodoCreateWithoutAssginInput!]
  createMany: TodoCreateManyAssginInputEnvelope
}

input TodoCreateNestedManyWithoutAuthorInput {
  connect: [TodoWhereUniqueInput!]
  connectOrCreate: [TodoCreateOrConnectWithoutAuthorInput!]
  create: [TodoCreateWithoutAuthorInput!]
  createMany: TodoCreateManyAuthorInputEnvelope
}

input TodoCreateOrConnectWithoutAssginInput {
  create: TodoCreateWithoutAssginInput!
  where: TodoWhereUniqueInput!
}

input TodoCreateOrConnectWithoutAuthorInput {
  create: TodoCreateWithoutAuthorInput!
  where: TodoWhereUniqueInput!
}

input TodoCreateWithoutAssginInput {
  author: UserCreateNestedOneWithoutCreatedTodosInput!
  body: String!
  createdAt: DateTime
  expiredAt: DateTime!
  title: String!
  updatedAt: DateTime
}

input TodoCreateWithoutAuthorInput {
  assgin: UserCreateNestedOneWithoutAssginTodosInput
  body: String!
  createdAt: DateTime
  expiredAt: DateTime!
  title: String!
  updatedAt: DateTime
}

type TodoGroupBy {
  _avg: TodoAvgAggregate
  _count: TodoCountAggregate
  _max: TodoMaxAggregate
  _min: TodoMinAggregate
  _sum: TodoSumAggregate
  assignById: Int
  authorId: Int!
  body: String!
  createdAt: DateTime!
  expiredAt: DateTime!
  id: Int!
  title: String!
  updatedAt: DateTime!
}

input TodoListRelationFilter {
  every: TodoWhereInput
  none: TodoWhereInput
  some: TodoWhereInput
}

type TodoMaxAggregate {
  assignById: Int
  authorId: Int
  body: String
  createdAt: DateTime
  expiredAt: DateTime
  id: Int
  title: String
  updatedAt: DateTime
}

input TodoMaxOrderByAggregateInput {
  assignById: SortOrder
  authorId: SortOrder
  body: SortOrder
  createdAt: SortOrder
  expiredAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type TodoMinAggregate {
  assignById: Int
  authorId: Int
  body: String
  createdAt: DateTime
  expiredAt: DateTime
  id: Int
  title: String
  updatedAt: DateTime
}

input TodoMinOrderByAggregateInput {
  assignById: SortOrder
  authorId: SortOrder
  body: SortOrder
  createdAt: SortOrder
  expiredAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input TodoOrderByRelationAggregateInput {
  _count: SortOrder
}

input TodoOrderByWithAggregationInput {
  _avg: TodoAvgOrderByAggregateInput
  _count: TodoCountOrderByAggregateInput
  _max: TodoMaxOrderByAggregateInput
  _min: TodoMinOrderByAggregateInput
  _sum: TodoSumOrderByAggregateInput
  assignById: SortOrder
  authorId: SortOrder
  body: SortOrder
  createdAt: SortOrder
  expiredAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input TodoOrderByWithRelationInput {
  assgin: UserOrderByWithRelationInput
  assignById: SortOrder
  author: UserOrderByWithRelationInput
  authorId: SortOrder
  body: SortOrder
  createdAt: SortOrder
  expiredAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

enum TodoScalarFieldEnum {
  assignById
  authorId
  body
  createdAt
  expiredAt
  id
  title
  updatedAt
}

input TodoScalarWhereInput {
  AND: [TodoScalarWhereInput!]
  assignById: IntNullableFilter
  authorId: IntFilter
  body: StringFilter
  createdAt: DateTimeFilter
  expiredAt: DateTimeFilter
  id: IntFilter
  NOT: [TodoScalarWhereInput!]
  OR: [TodoScalarWhereInput!]
  title: StringFilter
  updatedAt: DateTimeFilter
}

input TodoScalarWhereWithAggregatesInput {
  AND: [TodoScalarWhereWithAggregatesInput!]
  assignById: IntNullableWithAggregatesFilter
  authorId: IntWithAggregatesFilter
  body: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  expiredAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  NOT: [TodoScalarWhereWithAggregatesInput!]
  OR: [TodoScalarWhereWithAggregatesInput!]
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type TodoSumAggregate {
  assignById: Int
  authorId: Int
  id: Int
}

input TodoSumOrderByAggregateInput {
  assignById: SortOrder
  authorId: SortOrder
  id: SortOrder
}

input TodoUpdateInput {
  assgin: UserUpdateOneWithoutAssginTodosNestedInput
  author: UserUpdateOneRequiredWithoutCreatedTodosNestedInput
  body: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expiredAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TodoUpdateManyMutationInput {
  body: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expiredAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TodoUpdateManyWithoutAssginNestedInput {
  connect: [TodoWhereUniqueInput!]
  connectOrCreate: [TodoCreateOrConnectWithoutAssginInput!]
  create: [TodoCreateWithoutAssginInput!]
  createMany: TodoCreateManyAssginInputEnvelope
  delete: [TodoWhereUniqueInput!]
  deleteMany: [TodoScalarWhereInput!]
  disconnect: [TodoWhereUniqueInput!]
  set: [TodoWhereUniqueInput!]
  update: [TodoUpdateWithWhereUniqueWithoutAssginInput!]
  updateMany: [TodoUpdateManyWithWhereWithoutAssginInput!]
  upsert: [TodoUpsertWithWhereUniqueWithoutAssginInput!]
}

input TodoUpdateManyWithoutAuthorNestedInput {
  connect: [TodoWhereUniqueInput!]
  connectOrCreate: [TodoCreateOrConnectWithoutAuthorInput!]
  create: [TodoCreateWithoutAuthorInput!]
  createMany: TodoCreateManyAuthorInputEnvelope
  delete: [TodoWhereUniqueInput!]
  deleteMany: [TodoScalarWhereInput!]
  disconnect: [TodoWhereUniqueInput!]
  set: [TodoWhereUniqueInput!]
  update: [TodoUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [TodoUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [TodoUpsertWithWhereUniqueWithoutAuthorInput!]
}

input TodoUpdateManyWithWhereWithoutAssginInput {
  data: TodoUpdateManyMutationInput!
  where: TodoScalarWhereInput!
}

input TodoUpdateManyWithWhereWithoutAuthorInput {
  data: TodoUpdateManyMutationInput!
  where: TodoScalarWhereInput!
}

input TodoUpdateWithoutAssginInput {
  author: UserUpdateOneRequiredWithoutCreatedTodosNestedInput
  body: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expiredAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TodoUpdateWithoutAuthorInput {
  assgin: UserUpdateOneWithoutAssginTodosNestedInput
  body: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expiredAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TodoUpdateWithWhereUniqueWithoutAssginInput {
  data: TodoUpdateWithoutAssginInput!
  where: TodoWhereUniqueInput!
}

input TodoUpdateWithWhereUniqueWithoutAuthorInput {
  data: TodoUpdateWithoutAuthorInput!
  where: TodoWhereUniqueInput!
}

input TodoUpsertWithWhereUniqueWithoutAssginInput {
  create: TodoCreateWithoutAssginInput!
  update: TodoUpdateWithoutAssginInput!
  where: TodoWhereUniqueInput!
}

input TodoUpsertWithWhereUniqueWithoutAuthorInput {
  create: TodoCreateWithoutAuthorInput!
  update: TodoUpdateWithoutAuthorInput!
  where: TodoWhereUniqueInput!
}

input TodoWhereInput {
  AND: [TodoWhereInput!]
  assgin: UserRelationFilter
  assignById: IntNullableFilter
  author: UserRelationFilter
  authorId: IntFilter
  body: StringFilter
  createdAt: DateTimeFilter
  expiredAt: DateTimeFilter
  id: IntFilter
  NOT: [TodoWhereInput!]
  OR: [TodoWhereInput!]
  title: StringFilter
  updatedAt: DateTimeFilter
}

input TodoWhereUniqueInput {
  id: Int
}

type User {
  _count: UserCount
  assginTodos(cursor: TodoWhereUniqueInput, distinct: [TodoScalarFieldEnum!], orderBy: [TodoOrderByWithRelationInput!], skip: Int, take: Int, where: TodoWhereInput): [Todo!]!
  createdAt: DateTime!
  createdTodos(cursor: TodoWhereUniqueInput, distinct: [TodoScalarFieldEnum!], orderBy: [TodoOrderByWithRelationInput!], skip: Int, take: Int, where: TodoWhereInput): [Todo!]!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCount {
  assginTodos: Int!
  createdTodos: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  assginTodos: TodoCreateNestedManyWithoutAssginInput
  createdAt: DateTime
  createdTodos: TodoCreateNestedManyWithoutAuthorInput
  name: String!
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutAssginTodosInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAssginTodosInput
  create: UserCreateWithoutAssginTodosInput
}

input UserCreateNestedOneWithoutCreatedTodosInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCreatedTodosInput
  create: UserCreateWithoutCreatedTodosInput
}

input UserCreateOrConnectWithoutAssginTodosInput {
  create: UserCreateWithoutAssginTodosInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutCreatedTodosInput {
  create: UserCreateWithoutCreatedTodosInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAssginTodosInput {
  createdAt: DateTime
  createdTodos: TodoCreateNestedManyWithoutAuthorInput
  name: String!
  updatedAt: DateTime
}

input UserCreateWithoutCreatedTodosInput {
  assginTodos: TodoCreateNestedManyWithoutAssginInput
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

type UserMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  assginTodos: TodoOrderByRelationAggregateInput
  createdAt: SortOrder
  createdTodos: TodoOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  assginTodos: TodoUpdateManyWithoutAssginNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  createdTodos: TodoUpdateManyWithoutAuthorNestedInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutCreatedTodosNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCreatedTodosInput
  create: UserCreateWithoutCreatedTodosInput
  update: UserUpdateWithoutCreatedTodosInput
  upsert: UserUpsertWithoutCreatedTodosInput
}

input UserUpdateOneWithoutAssginTodosNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAssginTodosInput
  create: UserCreateWithoutAssginTodosInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutAssginTodosInput
  upsert: UserUpsertWithoutAssginTodosInput
}

input UserUpdateWithoutAssginTodosInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  createdTodos: TodoUpdateManyWithoutAuthorNestedInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutCreatedTodosInput {
  assginTodos: TodoUpdateManyWithoutAssginNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutAssginTodosInput {
  create: UserCreateWithoutAssginTodosInput!
  update: UserUpdateWithoutAssginTodosInput!
}

input UserUpsertWithoutCreatedTodosInput {
  create: UserCreateWithoutCreatedTodosInput!
  update: UserUpdateWithoutCreatedTodosInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  assginTodos: TodoListRelationFilter
  createdAt: DateTimeFilter
  createdTodos: TodoListRelationFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  id: Int
}
